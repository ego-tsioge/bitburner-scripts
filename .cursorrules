# General Rules

- Always respond in deutsch/german.
- Do not apologize, never!
- Do not thank me either!
- Talk to me like a human.
- Verify information before making changes
- Preserve existing code structures
- Provide concise and relevant responses
- Verify all information before making changes

You will be penalized if you:
	- Skip steps in your thought process
	- Add placeholders or TODOs for other developers
	- Deliver code that is not production-ready

I'm tipping $9000 for an optimal, elegant, minimal world-class solution that meets all specifications. Your code changes
should be specific and complete. Think through the problem step-by-step.

YOU MUST:
	- Follow the User's intent PRECISELY. If the user asks a question, answer that question only. Don't assume that a previous answer was wrong because of a question, unless that was mentioned in the question.
	- NEVER break existing functionality by removing/modifying code or CSS without knowing exactly how to restore the same
	function
	- Always strive to make your diff as tiny as possible

## File-by-file changes

- Make changes in small, incremental steps
- Test changes thoroughly before committing
- Document changes clearly in commit messages

## Code style and formatting

- Follow the project's coding standards
- Use consistent naming conventions
- Avoid using deprecated functions or libraries

## Debugging and testing

- Include debug information in log files
- Write unit tests for new code
- Ensure all tests pass before merging

## Project structure

- Maintain a clear and organized project structure
- Use meaningful names for files and directories
- Avoid clutter by removing unnecessary files

## CleanCode

### Don't Repeat Yourself (DRY)
Duplication of code can make code very difficult to maintain. Any change in logic can make the code prone to bugs or can make the code change difficult. This can be fixed by doing code reuse (DRY Principle).

The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system".

### Keep It Simple Stupid (KISS)
The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.

Simple code has the following benefits:
- less time to write
- less chances of bugs
- easier to understand, debug and modify
Do the simplest thing that could possibly work.

Don't make me think
Code should be easy to read and understand without much thinking. If it isn't then there is a prospect of simplification.

### You Aren't Gonna Need It (YAGNI)
You Aren't Gonna Need It (YAGNI) is an Extreme Programming (XP) practice which states: "Always implement things when you actually need them, never when you just foresee that you need them."

Even if you're totally, totally, totally sure that you'll need a feature, later on, don't implement it now. Usually, it'll turn out either:
- you don't need it after all, or
- what you actually need is quite different from what you foresaw needing earlier.
This doesn't mean you should avoid building flexibility into your code. It means you shouldn't overengineer something based on what you think you might need later on.

There are two main reasons to practice YAGNI:

You save time because you avoid writing code that you turn out not to need.
Your code is better because you avoid polluting it with 'guesses' that turn out to be more or less wrong but stick around anyway.
Premature Optimization is the Root of All Evil
Programmers waste enormous amounts of time thinking about or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.

### Boy-Scout Rule
Any time someone sees some code that isn't as clear as it should be, they should take the opportunity to fix it right there and then - or at least within a few minutes.

This opportunistic refactoring is referred to by Uncle Bob as following the boy-scout rule - always leave the code behind in a better state than you found it.

The code quality tends to degrade with each change. This results in technical debt. The Boy-Scout Principle saves us from that.

### Code for the Maintainer
Code maintenance is an expensive and difficult process. Always code considering someone else as the maintainer and making changes accordingly even if you're the maintainer. After a while, you'll remember the code as much as a stranger.

Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.

### Principle of Least Astonishment
Principle of Least Astonishment states that a component of a system should behave in a way that most users will expect it to behave. The behavior should not astonish or surprise users.

Code should do what the name and comments suggest. Conventions should be followed. Surprising side effects should be avoided as much as possible.

# Project specific rule

## Bitburner
- der Ordner "bitburner-gamefolder" entspricht dem spielinternen Root-Verzeichnis auf Server home
  -  alle Dateien in diesem Ordner werden vom Plugin "Bitburner VSCode Integration" an das Spiel übertragen
  - in diesem Ordner soll nur basis.js und eine weitere Datei zum Reinitialisieren aus GIT liegen
  - alle weiteren .js-Dateien kommen in den Unterordner "scripts"

## Projektfortschritt und Dokumentation
- die Datei "TODO.md" soll immer aktuell sein
	- geplante Änderungen sollen in "TODO.md" dokumentiert werden
	- abgeschlossene Änderungen sollen in "TODO.md" abgehakt werden
- die Datei "README.md" soll eine kurze Beschreibung des Projekts enthalten, über die Ordnerstruktur aufklären und für jede Datei eine kleine Beschreibung bieten

## GIT
- alle Änderungen sollen in GIT committed werden
  - Praktische Git-Konventionen: (Commit-Messages im Format "type: message")
    - fix: für Bugfixes
    - feat: für neue Features
    - refactor: für Umstrukturierungen
    - docs: für Dokumentation
    - test: für Tests

## spätere Absprachen
<!-- in diesen bereich sollen die Absprachen aufgenommen werden, die im Projektverlauf beschlossen wurden -->
- basis.js und alle mod.-dateien sollen:
  - nacheinander laufen. (übergabe nur mit ns.spawn, Status im localStorrage merken)
  - nicht mehr wie 8 GB Ram verbrauchen (das bezieht sich auf spielinternen Ram)
- Datenpersistenz
  - wenn Daten zum Status gemerkt werden müssen, dann sollen im localStorage gespeichert werden
  - Der Prefix für localStorage-Keys wird zentral in SETTINGS definiert
- devide and conquer
  - bei der problemlösung werden die Aufgaben in kleinere Teilaufgaben aufgeteilt
  - die Teilaufgaben werden nacheinander gelöst
  - Teilaufgaben werden in der TODO.md dokumentiert
  - die TODO.md soll immer aktuell sein
